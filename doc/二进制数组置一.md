# [3191]二进制数组全部置一的最少操作次数

## 题目描述

给你一个二进制数组 `nums` 。

你可以对数组执行以下操作 **任意** 次（也可以 0 次）：选择 3 个连续数字进行翻转。

翻转指的是将 1 变为 0 或者将 0 变为 1。

请你返回将 `nums` 中所有元素变为 1 的 **最少** 操作次数。如果无法全部变成 1 ，返回 -1 。

## 示例输入

示例1：

>   输入：nums = [0, 1, 1, 1, 0, 0]
>
>   输出：3
>
>   ①  nums = [1, 0, 0, 1, 0, 0]
>
>   ②  nums = [1, 1, 1, 0, 0, 0]
>
>   ③  nums = [1, 1, 1, 1, 1, 1]

示例2：

>   输入：nums = [0, 1, 1, 1, 0]
>
>   输出：-1
>
>   ①  nums = [1, 0, 0, 1, 0]
>
>   ②  nums = [1, 1, 1, 0, 0]
>
>   最后三个元素是 1 0 0 ，不论我们怎么翻转都不会全部变为 1。

## 题解

这道题目的思路其实很明了。

我们从数组的第一位开始，1 不用管， 遇到 0 就开始尝试着翻转 3 个数组元素，然后记为一次操作。

一直到数组中余下 3 个元素为止。

如果这三个元素全为 1，证明我们成功了，返回操作的次数。否则就永远也不可能成功，返回 -1。

```java
public int minOperations(int[] nums) {
    int n = nums.length;
    int operations = 0;

    for (int i = 0; i < n - 2; i++) {
        if (nums[i] == 0) {
            // 反转连续三个元素
            nums[i] ^= 1;
            nums[i + 1] ^= 1;
            nums[i + 2] ^= 1;
            operations++;
        }
    }

    // 检查最后两个元素是否为0
    if (nums[n - 1] == 0 || nums[n - 2] == 0) {
        return - 1;
    }

    return operations;
}
```

