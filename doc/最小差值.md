# [908]最小差值I

## 题目描述

给你一个整数数组 `nums`，和一个整数 `k` 。

在一个操作中，你可以选择 `0 <= i < nums.length` 的任何索引 `i` 。将 `nums[i]` 改为 `nums[i] + x` ，其中 `x` 是一个范围为 `[-k, k]` 的任意整数。对于每个索引 `i` ，最多 **只能** 应用 **一次** 此操作。

`nums` 的 **分数** 是 `nums` 中最大和最小元素的差值。

*在对 `nums` 中的每个索引最多应用一次上述操作后，返回 `nums` 的最低 **分数*** 。

## 示例输入

示例1：

>   输入：nums = [1]，k = 0
>
>   输出：0
>
>   max = 1，min = 1。差值为 0 。

示例2：

>   输入：nums = [1,  3,  6]，k = 3
>
>   输出：0
>
>   一种变换后 nums = [4,  4,  4]
>
>   max = 4，min = 4。差值为 0 。

示例3：

>   输入：nums = [0,  3, 10]，k = 2
>
>   输出：6
>
>   一种变换后 nums = [2,  3,  8]
>
>   max = 2,  min = 8。差值为 6 。

## 题解

这个题目思路很简单，先将数组排序。这样就能得到数组的最大值和最小值，从而得到一个**原始差值**。

如果这个原始差值小于`k`值的 2 倍，这个时候可以把数组调整同为一个数，结果自然为 0。比如示例 2。

否则的话就不能调整到一个数，这时我们把数组的最小值加 k，最大值减 k。其余值不变即可。比如示例 3。

```java
public int smallestRangeI(int[] nums, int k) {
    Arrays.sort(nums);
    int n = nums.length;
    int maxVal = nums[n - 1];
    int minVal = nums[0];
    int ans = maxVal - minVal;
    return Math.max(ans - 2 * k, 0);
}
```

# [910]最小差值II

## 题目描述

给你一个整数数组 `nums`，和一个整数 `k` 。

对于每个下标 `i`（`0 <= i < nums.length`），将 `nums[i]` 变成 `nums[i] + k` 或 `nums[i] - k` 。

`nums` 的 **分数** 是 `nums` 中最大元素和最小元素的差值。

在更改每个下标对应的值之后，返回 `nums` 的最小 **分数** 。

## 示例输入

>   输入：nums = [1]，k = 0
>
>   输出：0
>
>   max = 1，min = 1。差值为 0 。

示例2：

>   输入：nums = [1,  3,  6,  8]，k = 3
>
>   输出：3
>
>   一种变换后 nums = [4,  6,  3,  5]
>
>   max = 6，min = 3。差值为 3 。

示例3：

>   输入：nums = [0,  10]，k = 2
>
>   输出：6
>
>   一种变换后 nums = [2,  8]
>
>   max = 2,  min = 8。差值为 6 。

## 题解

和上面的思路类似，依然先对数组进行排序。然后进行第一步操作：

`nums[0] - k`，`nums[length-1] + k`，计算这个差值，记录下来，后面要与这个值进行比较。

从第二个元素开始遍历到倒数第二个元素，对于每个元素，尝试将其调整为 `nums[i] + k` 和 `nums[i] - k`，分别计算新的最大值和最小值，并更新最小差值。

```java
public int smallestRangeII(int[] nums, int k) {
    Arrays.sort(nums);
    int n = nums.length;
    int maxVal = nums[n - 1];
    int minVal = nums[0];
    int ans = (maxVal + k) - (minVal - k);
    for (int i = 1; i < n - 1; i++) {
        int a = nums[i], b = nums[i + 1];
        int high = Math.max(maxVal - k, a + k);
        int low = Math.min(minVal + k, b - k);
        ans = Math.min(ans, high - low);
    }
    return ans;
}
```

为了避免示例 3 的情况。因为这种情况下，不会进入循环，所以引入下面这种更通用的形式：

```java
public int smallestRangeII(int[] nums, int k) {
    Arrays.sort(nums);
    int n = nums.length;
    int maxVal = nums[n - 1];
    int minVal = nums[0];
    int ans = maxVal - minVal;
    for (int i = 0; i < n - 1; i++) {
        int a = nums[i], b = nums[i + 1];
        int high = Math.max(maxVal - k, a + k);
        int low = Math.min(minVal + k, b - k);
        ans = Math.min(ans, high - low);
    }
    return ans;
}
```

