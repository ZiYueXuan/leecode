# [72]编辑距离⭐⭐

## 题目描述

给你两个单词 `word1` 和 `word2`， *请返回将 `word1` 转换成 `word2` 所使用的最少操作数* 。

你可以对一个单词进行如下三种操作：

+   插入一个字符
+   删除一个字符
+   替换一个字符

## 示例输入

示例 1：

>   输入：word1 = "horse", word2 = "ros"
>
>   输出：3
>
>   horse -> rorse (将 'h' 替换为 'r') 
>
>   rorse -> rose (删除 'r') 
>
>   rose -> ros (删除 'e')

示例 2：

>   输入：word1 = "intention", word2 = "execution"
>
>   输出：5
>
>   intention -> inention (删除 't') 
>
>   inention -> enention (将 'i' 替换为 'e') 
>
>   enention -> exention (将 'n' 替换为 'x') 
>
>   exention -> exection (将 'n' 替换为 'c') 
>
>   exection -> execution (插入 'u')

## 题解

这是一道经典的动态规划问题。

`dp[i][j]` 代表 `word1` 到 `i` 位置转换成 `word2` 到 `j` 位置需要最少步数

当 `word1[i] == word2[j]`，`dp[i][j] = dp[i-1][j-1]`；

当 `word1[i] != word2[j]`，`dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1`

其中，`dp[i-1][j-1]` 表示替换操作，`dp[i-1][j]` 表示删除操作，`dp[i][j-1]` 表示插入操作。

|       |      | **r**                           | **o**                           | **s**                           |
| ----- | ---- | ------------------------------- | ------------------------------- | ------------------------------- |
|       | 0    | 1                               | 2                               | 3                               |
| **h** | 1    | **<font color="blue">1</font>** | **<font color="blue">2</font>** | **<font color="blue">3</font>** |
| **o** | 2    | **<font color="blue">2</font>** | **<font color="blue">1</font>** | **<font color="blue">2</font>** |
| **r** | 3    | **<font color="blue">2</font>** | **<font color="blue">2</font>** | **<font color="blue">2</font>** |
| **s** | 4    | **<font color="blue">3</font>** | **<font color="blue">3</font>** | **<font color="blue">2</font>** |
| **e** | 5    | **<font color="blue">4</font>** | **<font color="blue">4</font>** | **<font color="blue">3</font>** |

第一行，是 `word1` 为空变成 `word2` 最少步数，就是插入操作

第一列，是 `word2` 为空，需要的最少步数，就是删除操作

```java
public int minDistance(String word1, String word2) {
    int m = word1.length();
    int n = word2.length();

    int[][] dp = new int[m + 1][n + 1];

    // 初始化边界条件
    for (int i = 0; i <= m; i++) {
        dp[i][0] = i;
    }
    for (int j = 0; j <= n; j++) {
        dp[0][j] = j;
    }
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                // 选择插入、删除或替换操作中的最小操作数
                dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;
            }
        }
    }
    return dp[m][n];
}
```

