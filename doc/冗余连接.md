# 冗余连接

## [684]冗余连接I

### 题目描述

树可以看成是一个连通且 **无环** 的 **无向** 图。

给定往一棵 `n` 个节点 (节点值 `1～n`) 的树中添加一条边后的图。添加的边的两个顶点包含在 `1` 到 `n` 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 `n` 的二维数组 `edges` ，`edges[i] = [ai, bi]` 表示图中在 `ai` 和 `bi` 之间存在一条边。

请找出一条可以删去的边，删除后可使得剩余部分是一个有着 `n` 个节点的树。如果有多个答案，则返回数组 `edges` 中最后出现的那个。

### 示例输入

示例 1：

>   **输入**：edges = [[1,  2], [1,  3], [2,  3]]
>
>   **输出**：[2,  3]
>
>   ![image-202410281223184](https://gitee.com/ziyuexuan/image/raw/master/ziyuexuan/image/202410281223184.png)
>

示例 2：

>   **输入**：[[1,  2], [2,  3], [3,  4], [1,  4], [1,  5]]
>
>   **输出**：[1,  4]
>
>   ![image-20241028122616103](https://gitee.com/ziyuexuan/image/raw/master/ziyuexuan/image/202410281226145.png)

### 题解

这个题其实就是去掉一条边，使得图中不存在环。

我们可以使用并查集（Union-Find）来检测图中的环，并在检测到环时删除最后出现的那条边。

并查集：

```java
public class UnionFind {
    private int[] parent;
    private int[] rank;

    public UnionFind(int n) {
        parent = new int[n];
        rank = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            rank[i] = 0;
        }
    }

    public int find(int p) {
        if (parent[p] != p) {
            parent[p] = find(parent[p]);
        }
        return parent[p];
    }

    public boolean union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return false;
        if (rank[rootP] < rank[rootQ]) {
            parent[rootP] = rootQ;
        } else if (rank[rootP] > rank[rootQ]) {
            parent[rootQ] = rootP;
        }
        else {
            parent[rootQ] = rootP;
            rank[rootP]++;
        }
        return true;
    }
}
```

以下是具体的实现步骤：

1.  初始化并查集，用于管理每个节点的连通性。
2.  遍历每条边，尝试将两个节点合并。
3.  如果发现两个节点已经在同一个集合中，说明加入这条边会形成环，记录这条边。
4.  最后返回记录的边。

```java
public int[] findRedundantConnection(int[][] edges) {
    int n = edges.length;
    UnionFind unionFind = new UnionFind(n + 1);
    int[] result = new int[2];
    for (int[] edge: edges) {
        if (! unionFind.union(edge[0], edge[1])) {
            result = edge;
        }
    }
    return result;
}
```

## [685]冗余连接II

### 题目描述

在本问题中，有根树指满足以下条件的 **有向** 图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。

输入一个有向图，该图由一个有着 `n` 个节点（节点值不重复，从 `1` 到 `n`）的树及一条附加的有向边构成。附加的边包含在 `1` 到 `n` 中的两个不同顶点间，这条附加的边不属于树中已存在的边。

结果图是一个以边组成的二维数组 `edges` 。 每个元素是一对 `[ui, vi]`，用以表示 **有向** 图中连接顶点 `ui` 和顶点 `vi` 的边，其中 `ui` 是 `vi` 的一个父节点。

返回一条能删除的边，使得剩下的图是有 `n` 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。

### 示例输入

示例 1：

>   **输入：**edges = [[1,  2], [1,  3], [2,  3]] 
>
>   **输出：**[2,  3]
>
>   ![image-20241028171436064](https://gitee.com/ziyuexuan/image/raw/master/ziyuexuan/image/202410281714148.png)

示例 2：

>   **输入：**edges = [[1,  2], [2,  3], [3,  4], [4,  1], [1,  5]] 
>
>   **输出：**[4,  1]
>
>   ![image-20241028171619570](https://gitee.com/ziyuexuan/image/raw/master/ziyuexuan/image/202410281716626.png)

### 题解

这题和上面的题唯一的区别就是从无向图变成了有向图。

思路还是一样的，检查有向图中存不存在环，存在环的话去掉一条边。要注意的是因为是有向图，在去掉边的过程中要考虑每个节点入度不能超过 1。

并查集：

```java
public class UnionFind {
    private int[] parent;

    public UnionFind(int n) {
        parent = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }

    public int find(int p) {
        if (parent[p] != p) {
            parent[p] = find(parent[p]);
        }
        return parent[p];
    }

    public void union(int p, int q) {
        parent[find(p)] = find(q);
    }
}
```

1.   初始化：
2.   遍历边：

+   对于每条边 (node1, node2)：
+   如果 node2 已经有父节点，则记录冲突边的索引 conflict。
+   否则，更新 node2 的父节点为 node1，并检查是否形成环。如果形成环，记录环的索引 cycle，否则合并两个节点。

3.   处理结果：

+   如果没有冲突边，返回环的边。
+   如果有冲突边且有环，返回冲突边的父节点和冲突边的第二个节点。
+   如果有冲突边但没有环，返回冲突边。

```java
public int[] findRedundantDirectedConnection(int[][] edges) {
    int n = edges.length;
    UnionFind uf = new UnionFind(n + 1);
    int[] parent = new int[n + 1];
    for (int i = 1; i <= n; ++i) {
        parent[i] = i;
    }
    int conflict = -1;
    int cycle = -1;
    for (int i = 0; i < n; ++i) {
        int[] edge = edges[i];
        int node1 = edge[0], node2 = edge[1];
        if (parent[node2] != node2) {
            conflict = i;
        } else {
            parent[node2] = node1;
            if (uf.find(node1) == uf.find(node2)) {
                cycle = i;
            } else {
                uf.union(node1, node2);
            }
        }
    }
    if (conflict < 0) {
        return new int[]{edges[cycle][0], edges[cycle][1]};
    } else {
        int[] conflictEdge = edges[conflict];
        if (cycle >= 0) {
            return new int[]{parent[conflictEdge[1]], conflictEdge[1]};
        } else {
            return new int[]{conflictEdge[0], conflictEdge[1]};
        }
    }
}
```

