# 跳跃游戏

![img](https://gitee.com/ziyuexuan/image/raw/master/ziyuexuan/image/202410221806197.jpeg)

## [55]跳跃游戏I

### 题目描述

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

### 示例输入

示例1：

>   输入：nums = [2,  3,  1,  1,  4]
>
>   输出：true
>
>   可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。

示例2：

>   输入：nums = [3,  2,  1,  0,  4]
>
>   输出：false
>
>   无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。

### 题解

我们要通过一个数`maxReach`来记录最大可到达的位置。`maxReach`初始化为 0，遍历数组，如果当前位置可到达的位置更大，则更新。

遍历过程中，如果当前位置超出了最大可到达的位置，那就无法到达终点；如果最大可到达的位置超过了终点，可以到达。

```java
public boolean jump(int[] nums) {
    // 最大可到达的位置
    int maxReach = 0;
    int n = nums.length;
    for (int i = 0; i < n; i++) {
        if (i > maxReach) {
            // 当前位置超出了最大可到达的位置，无法到达终点
            return false;
        }
        maxReach = Math.max(maxReach, i + nums[i]);
        // 最大可到达的位置超过了终点，可以到达
        if (maxReach >= n - 1) {
            return true;
        }
    }
    return false;
}
```

## [45]跳跃游戏II

### 题目描述

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

请你返回可以到达 `nums[n - 1]`  的最小跳跃次数。题目保证可以到达最后一个位置。

### 示例输入

示例1：

>   输入：nums = [2,  3,  1,  1,  4]
>
>   输出：2
>
>   可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。

示例2：

>   输入：nums = [2,  1,  3,  0,  4,  1]
>
>   输出：2
>
>   可以先跳 2 步，从下标 0 到达下标 2，然后再跳 3 步到达最后一个下标

### 题解

使用贪心算法，维护两个变量：`currentEnd`（当前跳跃的范围结束位置）和 `furthest`（当前跳跃范围内能到达的最远位置）。

遍历数组，更新 `furthest`，表示在当前跳跃范围内能到达的最远位置。

当遍历到 `currentEnd` 时，表示我们需要进行一次跳跃，因此增加跳跃次数并更新 `currentEnd` 为 `furthest`。

```java
public static int jump(int[] nums) {
    int ans = 0;
    int n = nums.length;
    // 当前跳跃的范围结束位置
    int currentEnd = 0;
    // 当前跳跃的范围内可以到达的最远位置
    int furthest = 0;
    for (int i = 0; i < n - 1; i++) {
        furthest = Math.max(furthest, i + nums[i]);
        if (i == currentEnd) {
            ans++;
            currentEnd = furthest;
        }
    }
    return ans;
}
```

