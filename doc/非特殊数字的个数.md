# [3233]非特殊数字的个数

## 题目描述

给你两个 **正整数** `l` 和 `r`。对于任何数字 `x`，`x` 的所有正因数（除了 `x` 本身）被称为 `x` 的 **真因数**。

如果一个数字恰好仅有两个 **真因数**，则称该数字为 **特殊数字**。例如：

+   数字 4 是 **特殊数字**，因为它的真因数为 1 和 2。
+   数字 6 不是 **特殊数字**，因为它的真因数为 1、2 和 3。

返回区间 `[l, r]` 内 **不是 特殊数字** 的数字数量。

## 示例输入

示例 1：

>   输入：l = 5   r = 7
>
>   输出：3
>
>   区间 `[5, 7]` 内不存在特殊数字

示例 2：

>   输入：l = 4   r = 16
>
>   输出：11
>
>   区间 `[4, 16]` 内的特殊数字为 4 和 9。

## 题解

第一眼觉得这题思路挺清晰的，就是对于区间内的每一个数，获取它的因数数目（不包含数本身）。如果满足特殊数字的定义，那么计数加一即可。

```java
public int nonSpecialCount(int l, int r) {
    int number = 0;
    for (int i = l; i <= r; i++) {
        if (factorNum(i) != 2 ) number++;
    }
    return number;
}

private int factorNum(int n) {
    int count = 0;
    for (int i = 1; i <= Math.sqrt(n); i++) {
        if (n % i == 0) {
            count++;
            if (i != n / i) count++;
        }
    }
    return count - 1;
}
```

然后，不出所料，运行超时了。时间复杂度还是太高了。

紧接着我想到了另一种方法，那就是用一个数组来存储从 1 到 r 的因数的数目，然后扫描区间`[l, r]`，判断数组元素是不是 3 即可。

```java
public static int nonSpecialCount(int l, int r) {
    int[] factorCount = new int[r + 1];
    
    // 预处理每个数的因数数量
    for (int i = 1; i <= r; i++) {
        for (int j = i; j <= r; j += i) {
            factorCount[j]++;  // 对于每个 j，i 是它的因数
        }
    }
    
    // 统计区间 [l, r] 内非特殊数字的数量
    int count = 0;
    for (int i = l; i <= r; i++) {
        if (factorCount[i] != 3) {  // 特殊数字的因数个数是 3（包括 1 和平方根）
            count++;
        }
    }
    
    return count;
}
```

可当区间很大的时候，内存开销又太大了。又一次失败了。

我们考虑尽可能让时间复杂度和空间复杂度都要低。

我们得思考到底特殊数字是什么意思，特殊在哪。

第一眼看过去特殊数字一定是一个完全平方数。但存在例外，比如 16，它的因数（自身除外）有1，2，**4**，8；再比如36，它的因数（自身除外）有1，2，3，4，**6**，9，12，18……

通过上面的例子可以看出，这个完全平方数还要满足开根后的数字不能拆分，也就是说开根后的数字要是一个质数。

因此，我们可以在 `[1, sqrt(r)]` 的范围内遍历所有质数，然后将它们的平方从 `[1, r]` 的范围中去除即可。

```java
public int nonSpecialCount(int l, int r) {
    int sqrtR = (int) Math.sqrt(r);
    int[] array = new int[sqrtR + 1];
    int ans = r - l + 1;
    for (int i = 2; i <= sqrtR; i++) {
        if (array[i] == 0) {
            if (i * i >= l && i * i <= r) {
                ans--;
            }
            for (int j = i * 2; j <= sqrtR; j += i) {
                array[j] = 1;
            }
        }
    }
    return ans;
}
```

