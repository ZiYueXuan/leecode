# [935]骑士拨号器⭐⭐⭐

## 题目描述

象棋骑士有一个**独特的移动方式**，它可以垂直移动两个方格，水平移动一个方格，或者水平移动两个方格，垂直移动一个方格(两者都形成一个 **L** 的形状)。

象棋骑士可能的移动方式如下图所示：

![img](https://assets.leetcode.com/uploads/2020/08/18/chess.jpg)

我们有一个象棋骑士和一个电话垫，如下所示，骑士**只能站在一个数字单元格上**(即蓝色单元格)。

![img](https://gitee.com/ziyuexuan/image/raw/master/ziyuexuan/image/202412101524333.jpeg)

给定一个整数 n，返回我们可以拨多少个长度为 n 的不同电话号码。

你可以将骑士放置在**任何数字单元格**上，然后你应该执行 n - 1 次移动来获得长度为 n 的号码。所有的跳跃应该是**有效**的骑士跳跃。

因为答案可能很大，**所以输出答案模** `10^9 + 7`.

## 示例输入

示例 1：

>   输入：n = 1
>
>   输出：10
>
>   我们需要拨一个长度为1的数字，所以把骑士放在10个单元格中的任何一个数字单元格上都能满足条件。

示例 2：

>   输入：2
>
>   输出：20
>
>   我们可以拨打的所有有效号码为[04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94]

## 题解

易知骑士在“5”处无法移动，观察剩余9个数字。其中，除了4、6能往三个方向移动外，其他均为两个。

再经过观察，可将数字分为四类：

>   +   A = {1， 3， 7， 9}
>   +   B = {4，6}
>   +   C = {2， 8}
>   +   D = {0}
>
>   -----------------------
>
>   +   A –> B, C
>   +   B –> A, D
>   +   C –> A
>   +   D –> B

对于每个组，移动次数为：可移动位置 * 组内数量 * 组数

比如说对于数字`1`：**2（可移动位置）* 4（组内数量） *  A（组数）**

每个状态下的号码总数为当前状态下：
$$
(4*A+2*C+D)*2+B*2*3
$$

```java
public int knightDialer(int n) {
    long A = 1, B = 1, C = 1, D = 1;
    long res = 10L;
    long mod = 1000000007L;
    for (int i = 0; i < n - 1; i++) {
        A %= mod;
        B %= mod;
        C %= mod;
        D %= mod;
        res %= mod;
        res = (4 * A + 2 * C + D) * 2 + B * 2 * 3;
        long a = A, b = B, c = C, d = D;
        A = b + c;
        B = 2 * a + d;
        C = 2 * a;
        D = 2 * b;
    }
    return (int) (res % mod);
}
```

