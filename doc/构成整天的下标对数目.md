# 构成整天的下标对数目

## 题目描述

给你一个整数数组 `hours`，表示以 **小时** 为单位的时间，返回一个整数，表示满足 `i < j` 且 `hours[i] + hours[j]` 构成 **整天** 的下标对 `i`, `j` 的数目。

**整天** 定义为时间持续时间是 24 小时的 **整数倍** 。

例如，1 天是 24 小时，2 天是 48 小时，3 天是 72 小时，以此类推。

这道题目对应的是 `Leecode`的 3184 和 3185，希望你可以用两种方案实现。

## 示例输入

示例 1 ：

>   输入：hours = [12,  12,  30,  24,  24]
>
>   输出：2
>
>   构成整天的下标对分别是 `(0, 1)` 和 `(3, 4)`。

示例 2 ：

>   输入：hours = [72,  48,  24,  3]
>
>   输出：3
>
>   构成整天的下标对分别是 `(0, 1)`、`(0, 2)` 和 `(1, 2)`。

## 题解

首先最容易想到的肯定是双重循环，直接找到对应的下标，然后计数器加 1 就行了。

```java
public int countCompleteDayPairs(int[] hours) {
    int result = 0;
    int n = hours.length;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if ((hours[i] + hours[j]) % 24 == 0) {
                result++;
            }
        }
    }
    return result;
}
```

这个时间复杂度是 `O(n^2)`，可以通过`HashMap`来降低复杂度。

可以遍历数组：

1.  每个元素对 24 取模，记录出现的次数；
2.  对每个小时数，计算出其所需的配对小时数（即 `24 - currentHour`，如果为24，则为0）。
3.  检查这个配对小时数在哈希表中出现的次数，从而计算出可以形成整天的配对数。

```java
public long countCompleteDayPairsII(int[] hours) {
    HashMap<Integer, Long> map = new HashMap<>();
    long result = 0L;
    int n = hours.length;
    for (int hour : hours) {
        // 计算需要与当前时间配对的小时数
        int complement = (24 - hour % 24) % 24;
        // 如果这个配对小时数存在，则加上它出现的次数
        result += map.getOrDefault(complement, 0L);
        // 更新当前小时数出现的次数
        map.put(hour % 24, map.getOrDefault(hour % 24, 0L) + 1);
    }
    return result;
}
```

